
import os
import zipfile
import shutil
import subprocess
from tqdm import tqdm
import time

from Helpers.custom_printing import CustomPrinting
from Helpers.custom_markdown import CustomMarkdown

from config_03 import GIVEN_DIRECTORY, SUBMISSION_DIRECTORY, GIVEN_FILES, SUBMISSION_FILES, FILES_TO_COMPILE, PROTOCOL_LOCATION



def remove_path(path):
    try:
        os.remove(path)
    except PermissionError:
        shutil.rmtree(path)


def clear_submission_directory():
    for file_in_submission_directory in tqdm(list(filter(lambda x: os.path.isdir(f"{SUBMISSION_DIRECTORY}/{x}"), os.listdir(SUBMISSION_DIRECTORY)))):
        if os.path.isdir(f"{SUBMISSION_DIRECTORY}/{file_in_submission_directory}"):
            for file_to_remove in os.listdir(f"{SUBMISSION_DIRECTORY}/{file_in_submission_directory}"):
                if file_to_remove[-4:] != ".zip":
                    remove_path(f"{SUBMISSION_DIRECTORY}/{file_in_submission_directory}/{file_to_remove}")
        else:
            remove_path(f"{SUBMISSION_DIRECTORY}/{file_in_submission_directory}")



def test_homework():

    results = {}
    markdown_object = CustomMarkdown(PROTOCOL_LOCATION)
    markdown_object.write_h2("Testing all submissions for Homework 01")
    markdown_object.write_text(text=f"{len(os.listdir(SUBMISSION_DIRECTORY))} submissions have been tested.", bold=True, new_lines=1)



    # I wait a short amount of time so that the print statement won't get mixed up
    time.sleep(0.05)
    print("\nRemoving all unwanted files and directories inside the submission folder")
    time.sleep(0.05)
    clear_submission_directory()  # Removing all files except for the zip-file



    # I wait a short amount of time so that the print statement won't get mixed up
    time.sleep(0.05)
    print("\nInitializing testing and renaming directories")
    time.sleep(0.05)
    # Renaming all folders and initialize results dictionary
    # Sometimes there will be one more element listed in this loop:
    # ".DS_Store" -> generated by MacOS while changing files
    # You don't have to worry about that
    for file in tqdm(os.listdir(SUBMISSION_DIRECTORY)):

        # if file does not belong to submission
        # files or has been touched before
        if file[-6:] != "_file_":
            if file[:11] != "Submission_":
                # Remove all files that do not belong to the submission
                os.remove(SUBMISSION_DIRECTORY + "/" + file)
            else:
                # If folder belongs to submission files but has
                # been touch before -> Add to results dictionary
                # but do not rename
                name = file.replace("Submission_", "").replace("_", " ")
                results[name] = {}
            continue

        # Rename the folder to something more readable
        old_file_path = SUBMISSION_DIRECTORY + "/" + file
        name = file.replace("_assignsubmission_file_", "")[:-8]
        new_file_path = SUBMISSION_DIRECTORY + "/" + "Submission_" + name.replace(" ", "_")
        os.rename(old_file_path, new_file_path)
        results[name] = {}



    # I wait a short amount of time so that the print statement won't get mixed up
    time.sleep(0.05)
    print("\nTesting each submission")
    time.sleep(0.05)
    # Actually Testing each submission

    for file in tqdm(os.listdir(SUBMISSION_DIRECTORY)):

        # -------------------------------------------------------------------------------------------------------------
        # Test 1: Is there exactly one zip-file?

        name = file.replace("Submission_", "").replace("_", " ")
        student_path = SUBMISSION_DIRECTORY + "/" + file
        directory_content = os.listdir(student_path)

        # It is important to remove all created files after Testing. If
        # there is more than one file in the folder now then something is wrong
        if len(directory_content) > 1:
            results[name]["result"] = "Failed"
            results[name]["message"] = f"Too many zip-files in directory: {directory_content}"
            continue  # Jump to next attendee

        # -------------------------------------------------------------------------------------------------------------
        # Test 2: Does the zip-file contain all the required files?

        # Extract files from zip-files
        zip_file_path = student_path + "/" + directory_content[0]
        with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
            zip_ref.extractall(student_path)

        # If the contents of the folder do not match the requirements, which are:
        # Each students directory now has the zip-file in it and
        actual_files = os.listdir(student_path)
        desired_files = directory_content + SUBMISSION_FILES  # directory_content is just the zip-file from before

        wrong_files_submitted = False

        for desired_file in desired_files:
            if desired_file not in actual_files:
                wrong_files_submitted = True

        if wrong_files_submitted:
            results[name]["result"] = "Failed"
            results[name]["message"] = f"Wrong files in zip-file: Desired: {desired_files}, Actual: {actual_files}"
            continue  # Jump to next attendee

        # -------------------------------------------------------------------------------------------------------------
        # Test 3: Does Compilation work as expected?

        # Copy all given files into the students directory to compile them together
        for given_file in GIVEN_FILES:
            source = f"{GIVEN_DIRECTORY}/{given_file}"
            destination = f"{SUBMISSION_DIRECTORY}/{file}/{given_file}"
            shutil.copyfile(source, destination)

        # Determining the compilation string
        compilation_string = "gcc -Wall -Werror -std=c99"
        for file_to_compile in FILES_TO_COMPILE:
            compilation_string += " " + f"{SUBMISSION_DIRECTORY}/{file}/{file_to_compile}"
        compilation_string += f" -o {SUBMISSION_DIRECTORY}/{file}/program.out"

        # Compiling the file
        process = subprocess.Popen(compilation_string, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        output, error_message = process.communicate()
        exit_code = process.returncode

        if exit_code != 0:
            results[name]["result"] = "Failed"
            results[name]["message"] = f"Did not compile: {error_message.decode()}"
            results[name]["input"] = {}

            for homework_file in SUBMISSION_FILES:
                with open(f"{SUBMISSION_DIRECTORY}/{file}/{homework_file}", 'r') as homework_file_object:
                    results[name]["input"][homework_file] = homework_file_object.read()

            continue  # Jump to next attendee

        # -------------------------------------------------------------------------------------------------------------
        # Test 4 (Manual): Execute the file and store the generated output

        execution_string = f"./{SUBMISSION_DIRECTORY}/{file}/program.out"

        # Executing the file
        process = subprocess.Popen(execution_string, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        output, error_message = process.communicate()
        exit_code = process.returncode

        results[name]["result"] = "Success"
        results[name]["exit_code"] = exit_code
        results[name]["output"] = output.decode("utf-8", "replace")
        results[name]["input"] = {}

        for homework_file in SUBMISSION_FILES:
            with open(f"{SUBMISSION_DIRECTORY}/{file}/{homework_file}", 'r') as homework_file_object:
                results[name]["input"][homework_file] = homework_file_object.read()

        # -------------------------------------------------------------------------------------------------------------



    # I wait a short amount of time so that the print statement won't get mixed up
    time.sleep(0.05)
    print("\nRemoving all created files and directories")
    time.sleep(0.05)
    clear_submission_directory()  # Removing all files except for the zip-file



    # Generating the test protocol as a markdown file
    time.sleep(0.05)
    for name in sorted(results.keys()):
        markdown_object.write_horizontal_line()

        if results[name]["result"] == "Failed":
            markdown_object.write_h4(f"{name} -> Failed:", color=(255, 0, 0))
            markdown_object.write_codeblock(code=f"{results[name]['message']}", language="bash")
            if "input" in results[name]:
                for input_file in results[name]["input"]:
                    markdown_object.write_text(f"Input File `{input_file}`:", bold=True)
                    markdown_object.write_codeblock(code=results[name]["input"][input_file], language="c", new_lines=0)
        else:
            markdown_object.write_h4(f"{name} -> Successful until execution:", color=(0, 200, 0))
            markdown_object.write_text(f"Output Stream:", bold=True)
            markdown_object.write_codeblock(code=results[name]["output"], language="bash")

            for input_file in results[name]["input"]:
                markdown_object.write_text(f"Input File `{input_file}`:", bold=True)
                markdown_object.write_codeblock(code=results[name]["input"][input_file], language="c", new_lines=0)

    markdown_object.write_horizontal_line()



    # Print out a short version of the test protocol
    time.sleep(0.05)
    for name in sorted(results.keys()):
        CustomPrinting.print("\n" * 2 + "#" * 120 + "\n" * 2, bold=True)
        if results[name]["result"] == "Failed":
            CustomPrinting.print_red(f"{name} -> Failed:", bold=True)
            CustomPrinting.print_red(f"{results[name]['message']}")
        else:
            CustomPrinting.print_green(f"{name} -> Successful until execution:", bold=True)
            CustomPrinting.print_green(f"\nOutput Stream:", bold=True)
            CustomPrinting.print_green("-" * 60)
            CustomPrinting.print_green(results[name]["output"])
            CustomPrinting.print_green("-" * 60)

    CustomPrinting.print("\n" * 2 + "#" * 120 + "\n" * 2, bold=True)

